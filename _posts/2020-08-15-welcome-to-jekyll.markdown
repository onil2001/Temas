---
layout: post
title:  "Introduccion a la Ingenieria en software"
date:   2020-08-15 14:43:25 -0500
categories: jekyll update
---
<h2> Intoduccion </h2>
<h3> La Ingenieria en Software </h3>
*La economia de todos los paises desarrollados es dependiente del
software. <br>
*Actualmente cada vez mas sistemas son controlados por software. <br>
*La Ingenieria de Software concierne a teorias, metodos y herramientas
para el desarrollo profesional de software. <br>
*El gasto en la Ingenieria de Software representa un alto porcentaje del
PIB de los paises desarrollados 

<h3> Que es software? </h3>
Programas de computo y su documentacion asociada: requerimientos,
modelos de diseño y manuales de usuario.
El software puede ser generico o ad hoc. <br>
     <strong>I Generico: </strong> desarrollado para venderse a multiples clientes (Excel, Word,
     etc.) <br>
     <strong>I Ad hoc: </strong>desarrollado bajo demanda del cliente a un desarrollador
    especifico. <br>

El software nuevo puede ser creado desarrollando nuevos programas,
congurando sistemas de software generico o reutilizando software
existente.

<h3> Que es la Ingenieria en Software </h3>
Una disciplina de la Ingeniera que concierne a todos los aspectos de
la produccion de software <br>
Los Ingenieros de Software deben: <br>
Adoptar un enfoque sistematico para llevar a cabo su trabajo <br>
I Utilizar las herramientas y tecnicas mas apropiadas dependiendo <br>
<br>*del problema a resolver,
<br> *las restricciones del desarrollo y
<br> *los recursos disponibles.
<br>
<h3> Cual es la diferencia entre Ingeniera de Software y Ciencias
Computacionales? </h3>
 Las Ciencias Computacionales conciernen a la teoria y fundamentos
de cualquier sistema de computo (hardware o software). <br>
 La Ingenieria de Software concierne los aspectos practicos del
desarrollo y puesta en marcha de productos utiles de software. <br>
 La Ingenieria de Software aun esta lejos de ser considerada una
ciencia como los son la quimica o la fisica <br>

<h3> Cual es la diferencia entre Ingeniera de Software e Ingenieria de
Sistemas? </h3>
<br>La Ingenieria de Sistemas concierne a todos los aspectos del desarrollo
de sistemas basados en computo incluyendo hardware, software y la
ingenieria de procesos.

<h3> >Que es un proceso de software?</h3>
Un conjunto estructurado de actividades, cuya meta es el
desarrollo o evolucion de un software.
Algunas actividades genericas en todos los procesos de software son: <br>
<strong> Especificacion </strong>, que debe hacer el software y cuales son sus
especificaciones de desarrollo.<br>

<strong> Desarrollo </strong> produccion del sistema de software <br>

<strong> Validacion </strong> verificar que el software cumple con lo solicitado por el
cliente. <br>

<strong> Evolucion </strong> cambiar/adaptar el software a las nuevas demandas. <br>
Estas actividades varian dependiendo de la organizacion y del tipo de
sistema a desarrollarse. <br>

<h3> Cuales son los atributos de calidad de software?</h3> <br>
El software debe proveer la funcionalidad y desempe~no requeridos por el usuario y debe ser
mantenible, contable y aceptable <br>
<strong> Mantenible </strong> el software debe poder evolucionar para continuar
cumpliendo con las especificaciones. <br>
<strong> Confiable </strong> el software no debe causar da~nos fsicos o economicos en
el caso de que falle <br>
<strong> Eficiente </strong> el software no debe desperdiciar los recursos del sistema. <br>
<strong> Aceptable </strong> el software debe ser aceptado por los usuarios para los
que fue diseñado. Debe ser entendible, utilizable y compatible con
otros sistemas. <br>

<h3> ¿Cuales son los retos de la Ingenieria de Software?</h3> <br>
<strong> Heterogeneidad: </strong> Desarrollar tecnicas para construir software que
pueda hacer frente a plataformas y ambientes de ejecucion.
heterogeneos (diferentes tipos de Hw y Sw) <br>
<strong> Tiempos de entrega </strong> Desarrollar tecnicas que permitan reducir los
tiempos de entrega del software sin comprometer la calidad <br>
<strong> Confianza </strong> Desarrollar tecnicas que permitan que los usuarios
confien plenamente en el software. <br>


<h3><strong> DEFINICIÓN DE IS (CONTINÚA) </strong> </h3>
Bohem, 1976: Ingeniería del Software es la aplicación practica
del conocimiento científico en el diseño y construcción de
programas de computadora y la documentación necesaria
requerida para desarrollar, operar (funcionar) y mantenerlos. <br>

<h3> <strong> Definición de IS (resumiendo) </strong> </h3>
La ingeniería de software es una aplicación práctica del
conocimiento cientifico para proveer metodologías y técnicas
que ayuden a desarrollar sistemas de software a tiempo y a su
vez que aseguren que el desarrollador cumpla con las
expectativas de calidad y permanezca dentro del presupuesto.<br>

<h3><strong> Objetivos de la IS: </strong> </h3>
Diseñar programas informáticos que se adecúen a las exigencias
de la sociedad.
Liderar y acoplar el desarrollo de programaciones complicadas.
Actuar en todas las fases del ciclo de vida de un producto.
Computar los costos de un proyecto y evaluar los 7empos de
desarrollo.
Realizar el seguimiento de costes y plazos.
Liderar equipos de trabajo de desarrollo software. <br>

<h3> <strong> Objetivos de la IS (continúa) </strong> </h3>
Estructurar la elaboración de evidencias que comprueben el
perfecto funcionamiento de los programas y que se adaptan a
los requerimientos de análisis y diseño.
Diseñar, construir y administrar bases de datos.
Liderar y orientar a los programadores durante el desarrollo de
aplicaciones.
Incluir procesos de calidad en los sistemas, calculando métricas
e indicadores y chequeando la calidad del software producido. <br>

<h3><strong>  Origen de IS:  </strong></h3>
Ingeniería del So-ware, es el término utlizado por Fritz Bauer en la
primera conferencia sobre desarrollo de so-ware patrocinada por el
Comité de Ciencia de la OTAN celebrada en Garmisch (Alemania), en
octubre de 1968, previamente había sido utilizado por el
holandés Edsger Dijkstra en su obra The Humble Programmer.
Puede definirse según Alan Davis como "la aplicación inteligente de
principios probados, técnicas, lenguajes y herramientas para la
creación y mantenimiento, dentro de un coste razonable, de sofware
que satisfaga las necesidades de los usuarios".<br>

<h4><strong>  Origen de IS (continúa) </strong> </h4> 
Su origen se debió a que el entorno de desarrollo de sistemas
software adolecía de:
Retrasos considerables en la planificación
Poca productividad
Elevadas cargas de mantenimiento
Demandas cada vez más desfasadas frente a las ofertas
Baja calidad y fiabilidad del producto
Dependencia de los realizadores. <br>
<strong> -Esto es lo que se ha denominado habitualmente "crisis del
software", que históricamente se generó en los siguientes
pasos:</strong> <br>
-Primera Fase. Los albores (1945-1955)<br>
-Programar no es una tarea diferenciada del diseño de una
máquina. <br>
-Uso de lenguaje máquina y ensamblador.<br>
-Segunda Fase. El florecimiento (1955-1965)<br>
-Aparecen multitud de lenguajes<br>
-Se pensaba que era posible hacer casi todo.<br>

-Tercera Fase. La crisis (1965-1970)-Desarrollo inacabable de grandes programas<br>
-Ineficiencia, errores, coste impredecible<br>
-Nada es posible.<br>
-Cuarta Fase. Innovación conceptual (1970-1980)<br>
-Fundamentos de programación<br>
-Verificación de programas<br>
-Metodologías de diseño.<br>

-Quinta Fase. El diseño es el problema (1980-?)<br>
-Entornos de programación<br>
-Especificación formal<br>
-Programación automática.<br>

<h3><strong>  La evolución del software: </strong> </h3> <br> 
El término “evolución” del software se utiliza desde los sesenta
para denominar la dinámica de crecimiento del software.
Una definición atribuida a Lehman y Ramil dice que la evolución
del software es “todas las actividades de programación que se
orientan a generar una nueva versión de un so-ware a partir de
una versión anterior operativa. <br>

<h3> <strong> La crisis del software: </strong> </h3>
¿Cómo se define crisis?
-La palabra crisis se define en el diccionario como "un punto
decisivo en el curso de algo; momento, etapa, o evento decisivo
o crucial". Sin embargo para el software no ha habido ningún
punto crucial, sólo una lenta evolución.
-La crisis en la industria del software permanece durante
muchos años, lo cual parece una contradicción para el término.
Lo que si se podría decir es que hay un problema crónico en el
desarrollo de software. <br>

<h3> <strong> La crisis del software (continúa) </strong> </h3>
-Formalismo y metodología
-Herramientas de soporte
-Administración eficaz <br>

<h3> <strong>La crisis del software  </strong> </h3> <br>
Actualmente está surgiendo una gran expectativa ante la evolución de
la Ingeniería del Software, al ir apareciendo nuevos métodos y herramientas
formales que van a permitir en el futuro un planteamiento de ingeniería en
el proceso de elaboración de software.
Dicho planteamiento permitirá dar respuesta a los problemas de: <br>
- Administración <br>
- Calidad <br>
- Productividad <br>
- Fácil mantenimiento <br>
Este último es uno de los grandes problemas, pues puede llegar a suponer
un importe superior al 60% del total del coste del software.<br>

<h3> <strong>¿Por qué se crea la IS?  </strong> </h3>
-La ingeniería de software se crea debido a las siguientes características:
-El producto debe ser confiable y realizar sólo las tareas especificadas en los
requerimientos. <br>
-El producto debe ser robusto. Esto quiere decir que el software se comporta
de manera razonable, incluso en circunstancias no anticipadas desde el
principio. <br>
-El producto de software debe ser lo más reutilizable posible, de manera tal
que pueda ser incorporado en otro producto de software si se requiere. <br>
-El producto de software debe ser eficiente en el uso de los recursos del
sistema. <br>

<h3> <strong> ¿Por qué se crea la IS? (continúa) </strong> </h3> 
-Se requiere desarrollar el software en una manera que lo haga evolutivo,
de forma tal que se pueda agregar funcionalidad adicional sin efectos
perjudiciales. <br>
-El producto de software debe cumplir con los requerimientos de
rendimiento especificados, es decir, debe cumplir algunas de las restricciones
relacionadas al rendimiento. <br>
-El producto de software tendrá mayor valor si es portable, es decir que
puede trabajar bajo diferentes plataformas de software y ambientes
(hardware, sistemas operativos, etc.). <br>
-El producto de software debe ser utilizable, es decir, el aprendizaje de su
uso debe ser los suficientemente sencillo por parte de personas no
especialistas. <br>

<h3> <strong> El software en la actualidad: </strong>  </h3>
Las direcciones en las que evoluciona la ingeniería del so-ware
hoy en día pueden agruparse de la siguiente manera:
-Metodologías ágiles: métodos de desarrollo de so-ware
basados en procesos itera7vos e incrementales, donde los
requisitos y soluciones evolucionan durante la colaboración.
Metodologías como Scrum (1995), Extreme Programming
(1999) o DSDM (1995) fueron evolucionando hasta que en
Febrero del 2001 se publicó “Manifesto for Agile So-ware
Development” para definir la aproximación ahora conocida
como metodologías ágiles.<br>

<h3> <strong>El software en la actualidad (continúa)  </strong>  </h3> <br>
-Experimentación: es una rama de la ingeniería del software
interesada en realizar experimentos sobre software, recolectar
datos y deducir leyes y teorías de los mismos.
-Desarrollo dirigido por modelos: primero se desarrollan
modelos textuales gráficos del software a construir, y
posteriormente se construye el software.
-Líneas de productos software, en lugar de productos
individuales. <br>

<h2> <strong> FACTORES DE CALIDAD DEL SOFTWARE </strong> </h2> <br>
- Concepto de Calidad: Conjunto de propiedades y de características de un producto o servicio, que le confieren aptitud para satisfacer una necesidad explícita o implícita (ISO 8402).<br>
- Calidad del Software: Es el grado con el que un sistema, componente o proceso cumple los requerimientos especificados y las necesidades o expectativas del cliente o usuario.<br>

- Factores que determinan la calidad del software.<br>

- Se pueden clasificar en dos grandes grupos (Pressman):<br>

-Medidas Directas: La medida o medición decimos que es directa, cuando disponemos de un instrumento de medida que nos muestra un resultado (generalmente numérico).<br>

-Medidas Indirectas: Cuando hablamos de sistemas informáticos no siempre es posible realizar una medida directa, porque no disponemos del instrumento adecuado que nos permita realizar esa medición <br>

<h2> <strong> MÉTRICAS DEL SOFTWARE </strong> </h2> <br>
Son las que están relacionadas con el desarrollo del software como funcionalidad, complejidad, eficiencia.<br>

<strong> Entre las métricas del software tenemos las siguientes: </strong> <br>

<strong>  1. Métricas técnicas: </strong> Se centran en las características del software. Aquí medimos la complejidad lógica y el grado de modularidad del sistema. Mide la estructura del sistema, el cómo está hecho. <br>
<strong> 2. Métricas de calidad: </strong> Son todas las métricas de software que definen de una u otra forma la calidad del software; tales como corrección, exactitud, integridad, facilidad de uso, estructuración o modularidad, pruebas, facilidad de mantenimiento, reusabilidad, cohesión del módulo, acoplamiento del módulo, etc.<br>
Estas son los puntos críticos en el diseño, codificación, pruebas y mantenimiento.<br>
Proporcionan una indicación de cómo se ajusta el software a los requisitos implícitos y explícitos del cliente. Es decir cómo voy a medir para que mi sistema se adapte a los requisitos que me pide el cliente. <br>
<strong> - Corrección: </strong>  es el grado en que el software desempeña la función para la que fue creado y se mide en defectos por KLDC.<br>

<strong> - Facilidad de Mantenimiento:</strong> es la sencillez con que un programa puede corregirse si se encuentra un error, al adaptarse si su entorno cambio o mejorar si el cliente cambia los requisitos y se mide en forma indirecta en TMC (Tiempo Medio de Cambio).<br>
<strong> - Integridad:</strong> es la habilidad de un sistema para resistir ataques que requiere la definición de amenaza y seguridad y se calcula: integridad = 1 – (amenaza * (1 – seguridad)).Proceso de Ingeniería de software <br>

<h2> <strong> PROBLEMAS EN EL DESARROLLO DE SOFTWARE </strong> </h2> <br>
<h3> ¿Qué es un proyecto software? </h3> <br>
Haciendo uso de la definición de proyecto de la guía del PMBOK, y adaptándola a un proyecto software, podríamos definirlo como: “Un proyecto software es un esfuerzo temporal que se lleva a cabo para crear un producto software, servicio TI o resultado único.” <br>

<h3> <strong> ¿Pero que es el software? </strong> </h3> <br>

Según la definición del IEEE, "software es la suma total de los programas de ordenador, procedimientos, reglas, la documentación asociada y los datos que pertenecen a un sistema de cómputo", y "un producto de software es un producto diseñado para un usuario". <br>

<h4><strong>  El software puede dividirse en dos grandes categorías: </strong>  </h4><br>

<strong> Software de aplicaciones: </strong> se usan para proveer servicios a clientes y ejecutar negocios de forma más eficiente. El software de aplicaciones puede ser un sistema pequeño o uno grande integrado. Como ejemplos de este tipo de software estarían un sistema de cuentas, un sistema de planificación de recursos...<br>

<strong> -Software de sistemas:</strong> El software de sistemas se usa para operar y mantener un sistema informático. Permite a los usuarios usar los recursos del ordenador directamente y a través de otro software. Algunos ejemplos de este tipo de software son los sistemas operativos, compiladores y otras utilidades del sistema.<br>

Los proyectos software tienen características específicas que los hacen diferentes de otros proyectos de ingeniería.<br>

La Ingeniería del Software es la rama de la ingeniería que crea y mantiene las aplicaciones de software usando tecnologías y prácticas de las ciencias de la computación, manejo de proyectos, ingeniería, el ámbito de la aplicación, y otros campos.<br>

¿Por qué el software es diferente a cualquier otro proceso de fabricación? Podríamos identificar los siguientes motivos:<br>

-El software se desarrolla, no se fabrica en el sentido clásico de la palabra. Ambas actividades se dirigen a la construcción de un "producto", pero los métodos son diferentes. Los costes del software se encuentran en la ingeniería, esto implica que los proyectos no se pueden gestionar como si lo fueran de fabricación.<br>

-La juventud de la ingeniería del software con respecto a otras ingenierías, la mayoría del software se construye a medida, en vez de ensamblar componentes previamente creados. Aunque ya se están dando importantes pasos en esta dirección, que facilitaría en gran medida el desarrollo de aplicaciones informáticas.<br>

-En el software, el recurso principal son las personas. No es siempre posible acelerar la construcción de software añadiendo personas porque la construcción de software requiere un esfuerzo en equipo. El equipo tiene que trabajar de forma coordinada y compartir un objetivo de proyecto común. Se necesita comunicación efectiva dentro del equipo.<br>

-El software no se estropea, pero se deteriora. Durante su vida, el software sufre cambios (mantenimiento). Conforme se hacen los cambios, es bastante probable que se introduzcan nuevos defectos, lo que hace que el software se vaya deteriorando debido a estos cambios.<br>

<h2> <strong> IMPORTANCIA DEL PROCESO DE SW </strong> </h2> <br>
Un proceso software debe especificar:<br>
* La secuencia de actividades a realizar por el equipo de desarrollo<br>
-Flujo de actividades<br>
* Los productos que deben crearse<br>
-Resultados del trabajo (modelos, documentos, datos informes...)<br>

- Qué y cuándo<br>
*La asignación de tareas a cada miembro del equipo y al equipo como un todo<br>
-Los criterios para controlar el proceso<br>
- Se establece el control de gestión de los proyectos software<br>
- Establecimiento de hitos<br>
Las posibles heurísticas<br>
- Facilita la gestión del proyecto<br>
- Establece una división del trabajo<br>
* Facilita la comunicación de los miembros del equipo<br>
-Permite la reasignación y la reutilización de personal especializado<br>
-Transferencia entre proyectos<br>
* Mejora la productividad y el desarrollo<br>
-El desarrollo es reproducible<br>
* Establece el contexto en el que se aplican los métodos técnicos<br>
* Gestiona el cambio adecuadamente<br>
* Asegura la calidad<br>
<h1> <strong> ESTÁNDARES RELACIONADOS CON EL PROCESO DE SW </strong> </h1>
<h3> <strong> ESTÁNDAR ISO/IEC/IEEE 12207:2017 </strong> </h3>
- El estándar ISO/IEC/IEEE 12207:2017 [ISO/IEC/IEEE, 2017] relativo a los procesos del ciclo de vida del software <br>

- Se aplica a la adquisición de sistemas de software, productos y servicios, al suministro, desarrollo, operación, mantenimiento y eliminación de productos de software o componentes de software de cualquier sistema, ya sea que se realice interna o externamente a una organización.<br>

- Se incluyen aquellos aspectos de la definición del sistema necesarios para proporcionar el contexto de los productos y servicios de software.<br>

- También proporciona procesos que pueden emplearse para definir, controlar y mejorar los procesos del ciclo de vida del software dentro de una organización o de un proyecto.<br>

- Esta norma no fomenta o especifica ningún modelo concreto de ciclo de vida, gestión del software o método de ingeniería, ni prescribe cómo realizar ninguna de las actividades.<br>
<h1> <strong> Modelo de proceso de software </strong> </h1>
Representacion formal y simplificada de un proceso de software, <br>
presentada desde una perspectiva especifica<br>
Dicho de otra forma, los procesos son instancias de un modelo de
proceso<br>
Ejemplos de perspectivas del proceso de software:
I Flujo de trabajo, secuencia de actividades<br>
I Flujo de datos, <br>
ujo de la informacion<br>
I Rol/accion, quien realiza que<br>

<h2> <strong> Clasificacion de los modelos de procesos de software</strong> </h2> <br>
<strong> Modelos tradicionales </strong><br>
Formados por un conjunto de fases o actividades en las que no tienen en
cuenta la naturaleza evolutiva del software<br>
<strong>Modelos evolutivos</strong><br>
Son modelos que se adaptan a la evolucion que sufren los requisitos del
sistema en funcion del tiempo<br>
<strong>Modelos para sistemas orientados a objetos </strong><br>
Modelos con un alto grado de iteratividad y solapamiento entre fases
<strong> Modelos basados en reutilizacion </strong><br>
Tienen en cuenta la reutilizacion sistematica del software
<strong>Procesos agiles </strong><br>
Enfatizan el desarrollo rapido, ponen el enfasis en la programacion
<strong> Modelos para sistemas web </strong><br>
Creados especificamente para el desarrollo de aplicaciones web. <br>

<h3> <strong> Modelo de cascada</strong> </h3> <br>
<center><img src="https://raw.githubusercontent.com/onil2001/Temas/master/img/cascada.jpg" width="300" height="300"> </center> <br>
El primer modelo de desarrollo de sw que se publico en 1970. Este
toma las actividades fundamentales del proceso: especicacion,
desarrollo, validacion y evolucion, y las representa como fases <br>
El modelo en cascada consta de las siguientes fases: <br>
<strong> Definicion de los requisitos: </strong>  Los servicios, restricciones y objetivos
son establecidos con los usuarios del sistema.  <br>
<strong> Diseño de software: </strong> <br>
Se particiona el sistema en sistemas de software
o hardware. Se establece la arquitectura total del sistema. Se
identifcan y describen las abstracciones y relaciones de los
componentes del sistema. <br>
<strong>Implementacion y pruebas unitarias: </strong> Construccion de los modulos
y unidades de software. Se realizan pruebas de cada unidad. <br>
<strong>Implementacion y pruebas unitarias: </strong>
Se integran todas las unidades.
Se prueban en conjunto. Se entrega el conjunto probado al cliente.
<strong>Operacion y mantenimiento: </strong>Generalmente es la fase mas larga. El
sistema es puesto en marcha y se realiza la correccion de errores
descubiertos. Se realizan mejoras de implementacion. Se identifican
nuevos requisitos. <br>

<h3> <strong> Modelo con prototipos</strong> </h3> <br>
<center><img src="https://raw.githubusercontent.com/onil2001/Temas/master/img/prototipo.jpg" width="300" height="300"> </center> <br>
Un prototipo es un modelo experimental de un sistema o de un  componente de un sistema que tiene los suficientes elementos que  permiten su uso.
<br>
Son un medio eficaz para aclarar los requisitos de los usuarios e  identificar las caracter´ısticas de un sistema que deben cambiarse o  an˜adirse<br>
Mediante el prototipo se puede verificar la viabilidad del diseño de un  sistema <br>
Tiene un enfoque de desarrollo desechable (version rudimentaria del  sistema que luego se lo desecha), evolutivo (el prototipo debe  convertirse en el sistema final) y mixto (combinacion de prototipos  desechables y evolutivos).<br>
Enfoque de desarrollo que se utiliza cuando no se conoce con  seguridad lo que se quiere construir.<br>
<h3> <strong> Modelo incremental</strong> </h3> <br>
<center><img src="https://raw.githubusercontent.com/onil2001/Temas/master/img/incremental.png" width="300" height="300"> </center> <br>
Es un modelo derivado del ciclo de vida en cascada. Este modelo  busca reducir el riesgo que surge entre las necesidades del usuario y el  producto final por malos entendidos durante la etapa de recogida de  requisitos. <br>
Consiste en la iteraci´on de varios ciclos de vida en cascada. Al final de  cada iteraci´on se le entrega al cliente una versi´on mejorada o con  mayores funcionalidades del producto <br>
El cliente es quien despu´es de cada iteraci´on evalu´a el producto y lo  corrige o propone mejoras. <br>
Estas iteraciones se repetir´an hasta obtener un producto que satisfaga  las necesidades del cliente. <br>
Este modelo se suele utilizar en proyectos en los que los requisitos no  est´an claros por parte del usuario, por lo que se hace necesaria la  creaci´on de distintos prototipos para presentarlos y conseguir la  conformidad del cliente. <br>
<h3> <strong>Modelo iterativo</strong> </h3> <br>
<center><img src="https://raw.githubusercontent.com/onil2001/Temas/master/img/iterativo.jpg" width="300" height="300"> </center> <br>
Entrega un sistema completo desde el principio, para posteriormente  cambiar la funcionalidad de cada subsistema con cada version.<br>
Caracter´ısticas del ciclo iterativo [Muller, 1997] <br>
) Se basa en la evoluci´on de prototipos ejecutables, mensurables y  evaluables <br>
) Se van incorporando cambios en cada iteraci´on <br>
) Exige m´as atenci´on e implicaci´on de todos los actores del proyecto <br>
Para evaluar las iteraciones se deben definir criterios. <br>
<h3> <strong>Modelo en espiral</strong> </h3> <br>
<center><img src="https://raw.githubusercontent.com/onil2001/Temas/master/img/espiral.jpg" width="400" height="300"> </center> <br>
Es un modelo de proceso de software evolutivo, que proporciona el  potencial para el desarrollo r´apido de versiones incrementales del  software <br>
Se divide en un nu´mero de actividades estructurales, tambi´en  denominadas regiones de tareas. <br>
El avance se realiza desde el centro de la espiral hacia el exterior <br>
Reune caracter´ısticas del modelo cl´asico y de prototipos <br>
<h3> <strong>Modelo El proceso unificado </strong> </h3> <br>
<center><img src="https://raw.githubusercontent.com/onil2001/Temas/master/img/unificado.jpg" width="400" height="300"> </center> <br>
Definido por Rational Software Corporation [Jacobson et al., 2000] <br>
) Evoluci´on del proceso Objectory de Rational <br>
) Utilizaci´on de UML [Booch et al., 1999] como lenguaje de modelado <br>
) Basado en componentes <br>
Caracter´ısticas:
Conducido por casos de uso, para asegurar que toda la  funcionalidad se realiza en el sistema, se verifica y se prueba. el  sistema y verificar y probar el mismo <br>
Centrado en la arquitectura, ´esta se describe mediante diferentes  vistas del sistema <br>
El Proceso Unificado se repite a lo largo de una serie de ciclos, cuyas  fases por cada uno es:
Inicio, se define el alcance del proyecto y se desarrollan los casos de  negocio<br>
Elaboracion, se planifica el proyecto, se especifican en detalle la  mayor´ıa de los casos de uso y se disen˜a la arquitectura del sistema <br>
Construccion, se construye el producto <br>
Transicion, el producto se convierte en versi´on beta. Se corrigen  problemas y se incorporan mejoras sugeridas en la revisi´on <br>
<h3> <strong>basado en componentes</strong> </h3> <br>
<center><img src="https://raw.githubusercontent.com/onil2001/Temas/master/img/componentes.jpg" width="400" height="300"> </center> <br>
Para el desarrollo con reutilizaci´on debe ser posible encontrar los  componentes reutilizables apropiados <br>
Se debe confiar en que los componentes que se utilizan se comportan  conforme a lo especificado y son fiables <br>
Los componentes deben tener documentaci´on asociada para ayudar a  comprenderlos y adaptarlos a una nueva aplicacion <br>


<h3> <strong>Modelo agil</strong> </h3> <br>
<center><img src="https://raw.githubusercontent.com/onil2001/Temas/master/img/agil.jpg" width="400" height="300"> </center> <br>
Constituyen un nuevo enfoque en el desarrollo de software cuyas  principales caracter´ısticas son: <br>
Menor ´enfasis en el analisis, diseño y documentacion <br>  Equipos pequenos <br>
Desarrollo incremental<br>
Programacion (planificaci´on temporal) en cajas de tiempo  Supervivencia en un entorno ca´otico <br> <br>

h3> <strong>Scrum</strong> </h3> <br>
<center><img src="https://raw.githubusercontent.com/onil2001/Temas/master/img/scrum.jpg" width="400" height="300"> </center> <br>
h3> <strong>eXtreme Programming </strong> </h3> <br>
<center><img src="https://raw.githubusercontent.com/onil2001/Temas/master/img/xp.jpg" width="400" height="300"> </center> <br>









